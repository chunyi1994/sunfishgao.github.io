# 文科生必须了解的协程内幕

## 1.协程简介

协程相信大家都不陌生,他似乎有一种魔力,原来异步式的支离破碎的代码,引入协程以后,可以改写成同步式.可以大大改善开发效率.可以说是居家旅行必备.</br>
了解协程可能需要了解一些操作系统的知识,了解至少一个编程语言的内存模型.



##  2. 进程与线程

在介绍协程之前,不得不先说一下进程和线程.他们是操作系统分配资源和运行时间片的最小单位.

## 2.1 内核调度实体(Kernel Scheduling Entity, KSE)
linux下内核分配CPU执行的最小单位是KSE,即内核调度实体. 在早期还没有线程这个概念的时候,通常是使用多进程来实现服务器的高并发.后来引入了线程.(跑个题,引入线程出现了大量的线程安全问题.)其实linux内核并不区分执行单位是线程还是进程.linux执行单位是KSE. </br>
pthread里的线程和KSE是1:1的关系,所以线程也就是最小执行单位.

### 2.1.1 fork 与clone
do_fork系统api可选的可以共享父进程的一些资源,不共享的部分会复制一份成为新进程的资源.而最常见的fork()函数则不会共享任何资源(通常还有COW写时复制的优化).</br>
pthread的实现是使用linux内核提供的__clone系统调用.本质上还是调用do_fork(),但是它共享了父进程基本上所有的资源,但是自己会拥有一个独立的栈.pthread线程的本质其实也是轻量级进程.

## 2.2 地址与栈

我们知道进程是资源分配的最小单位.同一个进程里, 多个线程共同享有相同的地址空间(全局变量,堆),以及其他资源,比如file,信号等. 每个线程私有的属性有寄存器,errno,线程栈等.但是线程并没有独立的地址空间,所以不同线程栈分布在进程里的同一个地址空间里的不同位置.</br>
也就是说,倘若某个线程的栈溢出了,就会可能破坏掉别的线程栈,从而影响到别的线程的运行.</br>

### 2.2.1 线程栈

x86下linux线程栈是一个地址从高到低增长的先进后出的数据结构.线程栈的大小一般在8M~10M.所以我们不能一下子在栈中申请太多的内存,栈会爆掉.另一种情况是,随着函数的嵌套调用,栈指针会慢慢往下走.当发生调用函数过多(大部分情况是死循递归环调用),也会出现段错误的爆栈情况.

```
void fn() {
    int a[100];
    fn();
}

int main() {
   fn();
   return 0; 
}
```

这是一个死循环的递归, 每执行一次function,栈指针会往下指,也就是开辟一段空间执行程序(主要是开辟数组a),栈的空间容量就少了一些, 随着递归次数的增加,栈就爆了.</br>

相信很多小伙伴都实现过正则表达式引擎.教科书的语法分析方法,使用了递归下降来构造语法树,这里就一定要考虑到栈的问题.当正则表达式一大,就容易爆栈.

## 3.协程原理

### 3.1 调度原理

#### 3.1.1协程的调度节约了IO等待时间

简单地讲,先考虑单线程的情况.假设我们有三个IO密集型任务,任务A,任务B,任务C. 在不使用协程的情况下,完成他们的总耗时就是A+B+C的时间;在使用协程的情况下,A和B和C可以近似"并发"地一起执行, 总共耗时可能会小于A+B+C的时间. 在A,B,C任务不存在IO等待,只是单纯CPU计算任务的时候,使用协程并不能提高效率,反而因为调度(栈复制)的开销而丧失一些性能,反而会更慢.</br> 

#### 3.1.2为什么协程能节约IO等待时间

在不引入协程的情况下,使用c语言一般只能线性执行A,B,C三个任务.即A执行完了再执行B,再执行C.
但其实如果是IO密集型的任务,ABC任务会有大量时间在等待IO,这时候CPU利用率低,非常浪费.于是可以在A等待IO的时候,将其现场保存下来,然后去执行别的任务,过一段时间再回来看看,如果IO就绪就继续执行A,如果没就绪再切到别的任务上.就好比厨师只有一个人,如果先烧水,等水烧开了,再切菜,就有点浪费时间. 引入协程就可以先把水烧着,然后不管他,厨师这时候去切菜,等切好菜了水也就差不多烧开了.</br>


### 3.2 协程的使用

我理想中的协程库,接口尽可能简单,用法可以类似多线程或者goroutine那样.

```
//伪代码
int main() {
    Schedule s;
    s.go([] (Coroutine::Ptr co) {
        std::cout<<"1"<<"\n";
        co->yield();
        std::cout<<"2"<<"\n";
        co->yield();
        std::cout<<"3"<<"\n";
        co->yield();
    });
    
    s.go([] (Coroutine::Ptr co) {
        std::cout<<"A"<<"\n";
        co->yield();
        std::cout<<"B"<<"\n";
        co->yield();
        std::cout<<"C"<<"\n";
        co->yield();
    });
    s.run();
    return 0;
}
```
那么控制台输出结果应该会是1 A 2 B 3 C </br>

举一个更有意义的例子.
```

std::size_t readbytes(int fd,  //文件描述符
    char* src,                  //缓冲区
    std::size_t len,            //src长度
    std::size_t read_bytes,    //read_bytes 需要读的字节数
    Coroutine::Ptr co) {       //协程
    int n = 0;
    std::size_t readn = 0;
    while (true) {
        n = ::read(fd, src, len - readn);
        if (n < 0) {
            //处理错误
            if (errno == EAGAIN) {
                continue;
            }
            
            //return readn;
        }
        readn += static_cast<std::size_t>(n);
        src += n;
        if (readn == read_bytes) {
            return readn;
        }
        //让出时间片
        co->yield();
    }
}

```
这样就大致用协程实现了一个读到n个字节以后再返回的函数


### 3.2实现方式

协程的实现方式多种多样,在linux下,可以使用getcontext, 也可以使用c语言库的setjmp、longjmp实现协程.


## 注意事项

# 文科生必须了解的协程内幕

## 1.协程简介

协程相信大家都不陌生,他似乎有一种魔力,原来异步式的支离破碎的代码,引入协程以后,可以改写成同步式.可以大大改善开发效率.可以说是居家旅行必备.



##  2. 进程与线程

在介绍协程之前,不得不先说一下进程和线程.他们是操作系统分配资源和运行时间片的最小单位.



## 2.1 内核调度实体(Kernel Scheduling Entity, KSE)
linux下内核分配CPU执行的最小单位是KSE,即内核调度实体. 在早期还没有线程这个概念的时候,通常是使用多进程来实现服务器的高并发.后来引入了线程.(跑个题,引入线程出现了大量的线程安全问题.)其实linux内核并不区分执行单位是线程还是进程.linux执行单位是KSE.线程的本质其实也是轻量级进程. </br>
pthread里的线程和KSE是1:1的关系,所以线程也就是最小执行单位.

### 2.1.1 fork 与clone
do_fork系统api可选的可以共享父进程的一些资源,不共享的部分会复制一份成为新进程的资源.而最常见的fork()函数则不会共享任何资源(通常还有COW写时复制的优化).</br>
pthread的实现是使用linux内核提供的__clone系统调用.本质上还是调用do_fork(),但是它共享了父进程基本上所有的资源,但是自己会拥有一个独立的栈.

## 2.2 地址与栈

我们知道进程是资源分配的最小单位.同一个进程里, 多个线程共同享有相同的地址空间(全局变量,堆),以及其他资源,比如file,信号等. 每个线程私有的属性有寄存器,errno,线程栈等.但是线程并没有独立的地址空间,所以不同线程栈分布在进程里的同一个地址空间里的不同位置.</br>
也就是说,倘若某个线程的栈溢出了,就会可能破坏掉别的线程栈,从而影响到别的线程的运行.</br>

### 2.2.1 线程栈

线程栈的大小一般在8M~10M.

## 2.协程原理






### 3.1 调度原理




#### 3.1.1协程的调度节约了IO等待时间

简单地讲,先考虑单线程的情况.假设我们有三个IO密集型任务,任务A,任务B,任务C. 在不使用协程的情况下,完成他们的总耗时就是A+B+C的时间;在使用协程的情况下,A和B和C可以近似"并发"地一起执行, 总共耗时可能会小于A+B+C的时间. 在A,B,C任务不存在IO等待,只是单纯CPU计算任务的时候,使用协程并不能提高效率,反而因为调度(栈复制)的开销而丧失一些性能,反而会更慢.</br> 

#### 3.1.2为什么协程能节约IO等待时间

在不引入协程的情况下,使用c语言一般只能线性执行A,B,C三个任务.即A执行完了再执行B,再执行C.
但其实如果是IO密集型的任务,ABC任务会有大量时间在等待IO,这时候CPU利用率低,非常浪费.于是可以在A等待IO的时候,将其现场保存下来,然后去执行别的任务,过一段时间再回来看看,如果IO就绪就继续执行A,如果没就绪再切到别的任务上.就好比厨师只有一个人,如果先烧水,等水烧开了,再切菜,就有点浪费时间. 引入协程就可以先把水烧着,然后不管他,厨师这时候去切菜,等切好菜了水也就差不多烧开了.</br>



## 3.实现方式

协程的实现方式多种多样,在linux下,可以使用getcontext, 也可以使用


## 注意事项
